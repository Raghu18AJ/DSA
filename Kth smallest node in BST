Kth smallest node in BST

Moderate
80/80
Average time to solve is 15m

Problem statement
You have been given a Binary Search Tree of integers. You are supposed to return the k-th (1-indexed) smallest element in the tree.



For example:
For the given binary search tree and k = 3

The 3rd smallest node is highlighted in yellow colour.   

Sample Input 1:
3
10 5 15 4 7 14 16 -1 -1 -1 -1 -1 -1 -1 -1
Sample Output 1:
7
Explanation of Sample Input 1:

The third-smallest node is 7.

Sample Input 2:
2
-2 -4 1 -5 -1 -1 -1 -1 -1
Sample Output 2:
-4
Explanation of Sample Input 2:
The second-smallest node is -4.

Constraints:
1 <= N <= 10000
1 <= K <= N
-10^8 <= data <= 10^8 and data != -1

Where ‘N’ is the total number of nodes in the binary search tree, ‘K’ is the given integer and “data” is the value of the binary search tree node.

cpp code:
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode
    {
    public:
        T data;
        TreeNode<T> *left, *right;
        TreeNode() : data(0), left(NULL), right(NULL) {}
        TreeNode(T x) : data(x), left(NULL), right(NULL) {}
        TreeNode(T x, TreeNode<T> *left, TreeNode<T> *right) : data(x), left(left), right(right) {}
    };

************************************************************/
void solve(TreeNode<int> *root, vector<int> &arr){
	if(root == NULL){
		return ;
	}
	solve(root->left,arr);
	arr.push_back(root->data);
	solve(root->right,arr);
}
int kthSmallest(TreeNode<int> *root, int k)
{
    //  Write the code here.
	vector<int> arr;
	solve(root,arr);
	return arr[k-1];
}

Time Limit: 1sec
