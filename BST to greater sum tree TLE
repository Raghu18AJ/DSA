BST to greater sum tree

Difficulty: Medium
Accuracy: 66.73%
Submissions: 18K+
Points: 4

Given the root of a  BST with unique node values, transform it into greater sum tree where each node contains sum of all nodes greater than that node.

Examples:

Input: root = [11, 2, 29, 1, 7, 15, 40, N, N, N, N, N, N, 35, N]
      
Output: [119, 137, 75, 139, 130, 104, 0, N, N, N, N, N, N, 40, N]

Explanation: Every node is replaced with the sum of nodes greater than itself. 
      
Input: root = [2, 1, 6, N, N, 3, 7]
     
Output: [16, 18, 7, N, N, 13, 0]

Explanation: Every node is replaced with the sum of nodes greater than itself. 
     
Constraints :
1 ≤ node->data ≤ 3*104
1 ≤ number of nodes ≤ 3*104

Expected Complexities:
Time Complexity: O(n)
Auxiliary Space: O(n)

Company Tags:
Amazon
Microsoft

cpp code:

/*
class Node {
  public:
    int data;
    Node* left;
    Node* right;

    Node(int value) {
        data = value;
        left = nullptr;
        right = nullptr;
    }
};*/

class Solution {
  public:
    void solve2(Node* root,vector<int> arr){
        if(root==NULL){
            return ;
        }
        
        int sum = 0;
        for(int i = 0;i<arr.size();i++){
            if(root->data<arr[i]){
                sum += arr[i];
            }
        }
        root->data = sum;
        solve2(root->left,arr);
        solve2(root->right,arr);
    }
    void solve(Node* root, vector<int> &arr){
        if(root==NULL){
            return ;
        }
        
        arr.push_back(root->data);
        solve(root->left,arr);
        solve(root->right,arr);
        
    }
    void transformTree(Node *root) {
        // code here
        vector<int> arr;
        solve(root,arr);
        solve2(root,arr);
        
    }
};
