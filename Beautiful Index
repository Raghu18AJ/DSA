Beautiful Index
Easy
40/40
Average time to solve is 16m

Problem statement
You are given an array ‘A’ of length ‘N’. You say an index ‘i’ is beautiful if the sum of the first ‘i - 1’ elements of the array ‘A’ equals the sum of the last ‘N - i’ elements of the array ‘A’, where ‘i’ is in 1-based indexing. Now you wonder which is the leftmost beautiful index.

Note: If you select the first index, then the sum of the prefix will be ‘0’, and if you select the last index, then the sum of the suffix will be ‘0’.

Note: You have to print the index in 1-based indexing.

For example:

Let’s say the array ‘A’ = [1, 3, 1, 5], then if we select index ‘2’, the sum of the prefix is ‘1’, and the sum of the suffix is 1 + 5 = 6. Since the sum is not the same, hence index ‘2’ is not a beautiful index.
Detailed explanation ( Input/output format, Notes, Images )
Constraints -
1 <= ‘T’ <= 10
1 <= ‘N’ <= 10^5 
-10^9 <= A[i] <= 10^9, for 1 <= i <= ‘N’
Note- Sum of ‘N’ over all test cases does not exceed 10^5.

Time Limit: 1 sec
Sample Input-1
2
3
1 1 1
3
1 2 3
Sample Output-1
2
-1
Explanation for Sample Input 1:
For test case 1:
    Index ‘2’ is the leftmost beautiful index. The left sum is 1 and the right sum is also 1.
For test case 2:
    No index is beautiful.
Sample Input -2
2
6
1 7 3 6 5 6
3
2 1 -1
Sample Output -2
4
1

cpp code:-

#include <bits/stdc++.h> 
int beautifulIndex(int N, vector<int> A)
{
	// Write your code here.
	int totalSum = 0;
	for(int i = 0;i<N;i++){
		totalSum += A[i];
	}
	int leftSum = 0;
	for(int i = 0;i<N;i++){
		if(2*leftSum == totalSum-A[i]){
			return i+1;
		}
		leftSum += A[i];
	}
	return -1;
}
